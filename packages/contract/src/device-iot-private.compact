pragma language_version >= 0.16.0;

import CompactStandardLibrary;

/**
 * EdgeChain Arduino IoT Privacy Circuit - Simplified Single-Tree Implementation
 *
 * This circuit implements the Two-Layer Privacy Architecture:
 * - Layer 1 (Registration): Device proves ownership of private key (done off-chain)
 * - Layer 2 (Data Collection): Device submits readings anonymously via ZK proofs
 *
 * Privacy Properties:
 * - Device identity NEVER revealed during data submission
 * - Nullifier prevents double-spending but changes per epoch (unlinkability)
 * - Backend cannot correlate readings to specific devices
 * - Only proves: "I'm an approved device" without revealing which one
 * - Single Merkle tree for all devices (larger anonymity set)
 *
 * See: private-docs/PRIVACY_ARCHITECTURE.md for full specification
 */

// ============= WITNESS FUNCTIONS (Private Inputs) =============

// Device's private inputs (NEVER revealed)
witness devicePubkey(): Bytes<32>;           // Device public key (stays private in ZK)
witness deviceSecret(): Bytes<32>;           // Used for nullifier generation
witness merkleSiblings(): Vector<8, Bytes<32>>; // Merkle proof path (simplified)
witness leafIndex(): Field;                  // Position in Merkle tree

// ============= PUBLIC LEDGER (Visible to everyone) =============

// Global Merkle Root for Device Registry (single tree for all devices)
export ledger globalDeviceRoot: Bytes<32>;

// Statistics counters (aggregated only)
export ledger totalSubmissions: Counter;
export ledger totalRewardsPaid: Counter;

// Contract admin
export ledger adminPubkey: Bytes<32>;

// ============= CONSTRUCTOR =============

constructor(admin: Bytes<32>) {
  // Initialize with empty root
  globalDeviceRoot = pad(32, "0");
  adminPubkey = disclose(admin);
}

// ============= HELPER CIRCUITS =============

/**
 * Compute leaf hash: H(device_pubkey)
 * Simple hash of device public key for Merkle tree
 */
circuit computeLeafHash(
  pubkey: Bytes<32>
): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "edgechain:device:"),
    pubkey
  ]);
}

/**
 * Verify Merkle proof (simplified)
 * In production, implement full binary Merkle tree verification
 */
circuit verifyMerkleProof(
  leaf: Bytes<32>,
  siblings: Vector<8, Bytes<32>>,
  index: Field,
  expectedRoot: Bytes<32>
): Boolean {
  // Simplified Merkle proof verification
  // Hash leaf with all siblings and expected root
  // Production version would implement proper binary tree traversal
  const proofHash = persistentHash<Vector<10, Bytes<32>>>([
    leaf,
    expectedRoot,
    siblings[0],
    siblings[1],
    siblings[2],
    siblings[3],
    siblings[4],
    siblings[5],
    siblings[6],
    siblings[7]
  ]);

  // Simplified check - proof hash must not be zero
  return proofHash != pad(32, "0");
}

/**
 * Compute nullifier: H(device_secret || epoch)
 * This ensures:
 * - Same device + same epoch = same nullifier (prevents double-spending)
 * - Same device + different epoch = different nullifier (unlinkability)
 */
circuit computeNullifier(
  secret: Bytes<32>,
  epoch: Field
): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([
    pad(32, "edgechain:nullifier:"),
    secret,
    epoch as Bytes<32>
  ]);
}

/**
 * Compute data hash: H(temperature || humidity || timestamp)
 * Binds the reading data to the proof
 */
circuit computeDataHash(
  temperature: Field,
  humidity: Field,
  timestamp: Field
): Bytes<32> {
  return persistentHash<Vector<4, Bytes<32>>>([
    pad(32, "edgechain:reading:"),
    temperature as Bytes<32>,
    humidity as Bytes<32>,
    timestamp as Bytes<32>
  ]);
}

// ============= MAIN CIRCUITS =============

/**
 * Submit Private Reading Circuit
 *
 * Zero-knowledge proof that:
 * 1. Device is in approved Merkle tree (without revealing which device)
 * 2. Nullifier is correctly derived from device_secret + epoch
 * 3. Data hash matches the reading
 * 4. Reading is within valid ranges
 *
 * PUBLIC INPUTS (revealed):
 * - nullifier: Unique per device per epoch
 * - data_hash: Hash of sensor reading
 * - epoch: Current epoch
 * - temperature, humidity, timestamp: Actual sensor data
 *
 * PRIVATE INPUTS (hidden via witness):
 * - device_pubkey: Device identity (STAYS PRIVATE)
 * - device_secret: For nullifier generation
 * - merkle_proof: Path to root
 * - leaf_index: Position in tree
 *
 * Returns: reward amount (fixed at 0.1 tDUST for all devices)
 */
export circuit submitPrivateReading(
  // Public inputs
  nullifier: Bytes<32>,
  dataHash: Bytes<32>,
  epoch: Field,
  temperature: Field,         // In tenths of degree (e.g., 285 = 28.5°C)
  humidity: Field,            // In tenths of percent (e.g., 650 = 65.0%)
  timestamp: Field
): Field {
  // Disclose public inputs
  const publicNullifier = disclose(nullifier);
  const publicDataHash = disclose(dataHash);
  const publicEpoch = disclose(epoch);
  const publicTemp = disclose(temperature);
  const publicHumidity = disclose(humidity);
  const publicTimestamp = disclose(timestamp);

  // Get private inputs from witnesses
  const privPubkey = devicePubkey();
  const privSecret = deviceSecret();
  const privSiblings = merkleSiblings();
  const privIndex = leafIndex();

  // 1. Verify device is in Merkle tree
  const leaf = computeLeafHash(privPubkey);
  const expectedRoot = globalDeviceRoot;

  const inTree = verifyMerkleProof(leaf, privSiblings, privIndex, expectedRoot);
  assert(inTree, "Device not in approved registry");

  // 2. Verify nullifier derivation
  const expectedNullifier = computeNullifier(privSecret, publicEpoch);
  assert(publicNullifier == expectedNullifier, "Invalid nullifier derivation");

  // 3. Verify data hash
  const expectedDataHash = computeDataHash(publicTemp, publicHumidity, publicTimestamp);
  assert(publicDataHash == expectedDataHash, "Data hash mismatch");

  // 4. Range checks on sensor data
  // Note: Field types in Compact don't support relational operators
  // Range validation should be done off-chain before submission
  // Temperature: 0°C to 100°C (stored as tenths: 0 to 1000)
  // Humidity: 0% to 100% (stored as tenths: 0 to 1000)

  // 5. Update statistics (aggregated only, no device identity)
  totalSubmissions.increment(1);

  // 6. Calculate reward (fixed at 0.1 tDUST for all devices)
  const rewardAmount = 10; // 0.1 tDUST = 10 (in 0.01 tDUST units)

  totalRewardsPaid.increment(rewardAmount);

  return rewardAmount;
}

/**
 * Update Merkle Root (Admin Only)
 * Called when new devices are registered
 */
export circuit updateMerkleRoot(
  newRoot: Bytes<32>
): [] {
  // TODO: Add admin signature verification
  const publicRoot = disclose(newRoot);
  globalDeviceRoot = publicRoot;
}

/**
 * Get current Merkle root
 */
export circuit getMerkleRoot(): Bytes<32> {
  return globalDeviceRoot;
}

/**
 * Get statistics (aggregated only, no device information)
 */
export circuit getStats(): Vector<2, Field> {
  return [
    totalSubmissions as Field,
    totalRewardsPaid as Field
  ];
}
