pragma language_version >= 0.16.0;

import CompactStandardLibrary;

/**
 * EdgeChain Arduino IoT Smart Contract - Simplified Single-Tree Version
 *
 * Architecture:
 * - Single Merkle Root: One tree for all devices (larger anonymity set)
 * - Device Registry: On-chain Merkle root for verification
 * - Batch Processing: Track batches with ZK proofs
 * - Nullifier Tracking: Prevent replay attacks
 * - Fixed Rewards: 0.1 tDUST for all verified readings
 *
 * Note: This is a simplified version focusing on getting the core logic working
 * Production version would have full EdDSA signature verification and Merkle proof verification
 */

// ============= WITNESS FUNCTIONS (Private Inputs) =============

// Witness: Device's signature data (stays private)
witness deviceSignature(): Bytes<64>;

// Witness: Merkle proof siblings (stays private)
witness merkleSiblings(): Vector<8, Bytes<32>>;

// ============= PUBLIC LEDGER (Visible to everyone) =============

// Global Merkle Root for Device Registry (single tree for all devices)
export ledger globalDeviceRoot: Bytes<32>;

// Nullifier tracking (simplified - in production, use proper storage)
// Using last nullifier as simple check
export ledger lastNullifier: Bytes<32>;

// Statistics counters
export ledger totalBatchesVerified: Counter;
export ledger totalRewardsPaid: Counter;

// Contract admin
export ledger adminPubkey: Bytes<32>;

// ============= CONSTRUCTOR =============

constructor(admin: Bytes<32>) {
  // Initialize with empty root
  globalDeviceRoot = pad(32, "0");
  adminPubkey = disclose(admin);
  lastNullifier = pad(32, "0");
}

// ============= HELPER CIRCUITS =============

/**
 * Compute leaf hash: H(device_pubkey)
 */
export circuit computeLeafHash(
  devicePubkey: Bytes<32>
): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([
    pad(32, "edgechain:device:"),
    devicePubkey
  ]);
}

/**
 * Verify that device is authorized (simplified)
 * Note: This circuit must NOT be exported to avoid witness disclosure
 */
circuit verifyDeviceAuthorization(
  devicePubkey: Bytes<32>,
  expectedRoot: Bytes<32>
): Boolean {
  // Compute leaf hash
  const leaf = computeLeafHash(devicePubkey);

  // Get Merkle siblings from witness
  const siblings = merkleSiblings();

  // Simplified verification: hash leaf with siblings
  const proofHash = persistentHash<Vector<10, Bytes<32>>>([
    leaf,
    expectedRoot,
    siblings[0],
    siblings[1],
    siblings[2],
    siblings[3],
    siblings[4],
    siblings[5],
    siblings[6],
    siblings[7]
  ]);

  // Simplified check - in production, implement full Merkle path verification
  return proofHash != pad(32, "0");
}

// ============= MAIN CIRCUITS =============

/**
 * Submit Sensor Batch Circuit
 *
 * Verifies batch and returns reward amount (fixed at 0.1 tDUST for all devices)
 */
export circuit submitSensorBatch(
  devicePubkey: Bytes<32>,
  batchHash: Bytes<32>,
  nullifier: Bytes<32>
): Field {
  // Disclose public inputs (these are intentionally public)
  const publicNullifier = disclose(nullifier);

  // 1. Check nullifier not used (simplified - check against last nullifier)
  // In production, use proper nullifier set with Merkle tree or database
  assert(publicNullifier != lastNullifier, "Nullifier already spent");

  // 2. Get Merkle root
  const expectedRoot = globalDeviceRoot;

  // 3. Verify device authorization
  const authorized = verifyDeviceAuthorization(devicePubkey, expectedRoot);
  assert(authorized, "Device not authorized");

  // 4. Verify signature (simplified - get from witness)
  const signature = deviceSignature();

  // Simplified signature check: H(devicePubkey || batchHash) != 0
  // In production, verify EdDSA signature properly
  const signatureHash = persistentHash<Vector<2, Bytes<32>>>([
    devicePubkey,
    batchHash
  ]);
  assert(signatureHash != pad(32, "0"), "Invalid signature");

  // 5. Store nullifier as last used
  lastNullifier = publicNullifier;

  // 6. Update counters
  totalBatchesVerified.increment(1);

  // 7. Calculate reward (fixed at 0.1 tDUST for all devices)
  const rewardAmount = 10; // 0.1 tDUST = 10 (in 0.01 tDUST units)

  totalRewardsPaid.increment(rewardAmount);

  return rewardAmount;
}

/**
 * Update Merkle Root (Admin Only)
 */
export circuit updateMerkleRoot(
  newRoot: Bytes<32>
): [] {
  // TODO: Add admin signature verification
  globalDeviceRoot = disclose(newRoot);
}

/**
 * Get current Merkle root
 */
export circuit getMerkleRoot(): Bytes<32> {
  return globalDeviceRoot;
}

/**
 * Check if nullifier is spent (simplified)
 */
export circuit isNullifierSpent(nullifier: Bytes<32>): Boolean {
  return nullifier == lastNullifier;
}

/**
 * Get statistics
 */
export circuit getStats(): Vector<2, Field> {
  return [
    totalBatchesVerified as Field,
    totalRewardsPaid as Field
  ];
}
