/**
 * Midnight Network Integration Library
 *
 * Provides utilities for interacting with Midnight Network:
 * - Provider initialization
 * - ZK configuration
 * - Contract deployment and interaction
 */

import { Contract as EdgeChainContract, ledger } from '@edgechain/contract/dist/managed/edgechain/contract/index.cjs';
import type { Ledger } from '@edgechain/contract/dist/managed/edgechain/contract/index.cjs';
import type { DAppConnectorAPI } from '@midnight-ntwrk/dapp-connector-api';

// Import Midnight.js providers
import {
  createFetchZkConfigProvider
} from '@midnight-ntwrk/midnight-js-fetch-zk-config-provider';

import {
  createHttpClientProofProvider
} from '@midnight-ntwrk/midnight-js-http-client-proof-provider';

import {
  createIndexerPublicDataProvider
} from '@midnight-ntwrk/midnight-js-indexer-public-data-provider';

import {
  createLevelPrivateStateProvider
} from '@midnight-ntwrk/midnight-js-level-private-state-provider';

/**
 * Midnight Network Configuration
 */
export interface MidnightConfig {
  indexerUrl: string;
  indexerWs?: string;
  proofServerUrl?: string;
  nodeUrl?: string;
  contractAddress?: string;
}

/**
 * Get Midnight configuration from environment
 */
export function getMidnightConfig(): MidnightConfig {
  return {
    indexerUrl: import.meta.env.VITE_MIDNIGHT_INDEXER_URL || 'https://indexer.devnet.midnight.network',
    indexerWs: import.meta.env.VITE_MIDNIGHT_INDEXER_WS || 'wss://indexer.devnet.midnight.network',
    proofServerUrl: import.meta.env.VITE_MIDNIGHT_PROOF_SERVER,
    nodeUrl: import.meta.env.VITE_MIDNIGHT_NODE_URL || 'https://rpc.devnet.midnight.network',
    contractAddress: import.meta.env.VITE_CONTRACT_ADDRESS,
  };
}

/**
 * Create Midnight providers for contract interaction
 */
export async function createMidnightProviders(
  walletApi: DAppConnectorAPI,
  config: MidnightConfig
) {
  console.log('üîß Creating Midnight providers...');

  try {
    // 1. ZK Configuration Provider
    // This loads the ZK circuit parameters from the build output
    console.log('  ‚öôÔ∏è  Initializing ZK config provider...');
    const zkConfigProvider = createFetchZkConfigProvider(
      window.location.origin, // Base URL for fetching ZK artifacts
      '/keys/',               // Path to proving/verification keys
      '/zkir/'                // Path to circuit IR
    );

    // 2. Public Data Provider (Indexer)
    // This provides read-only access to blockchain state
    console.log('  ‚öôÔ∏è  Initializing indexer provider...');
    const publicDataProvider = await createIndexerPublicDataProvider(
      config.indexerUrl,
      config.indexerWs
    );

    // 3. Private State Provider
    // This manages local private state (encrypted data)
    console.log('  ‚öôÔ∏è  Initializing private state provider...');
    const privateStateProvider = createLevelPrivateStateProvider({
      privateStateStoreName: `edgechain-private-state-${walletApi}`,
    });

    // 4. Proof Provider
    // This generates ZK proofs for circuit execution
    console.log('  ‚öôÔ∏è  Initializing proof provider...');

    let proofProvider;
    if (config.proofServerUrl) {
      // Use remote proof server (recommended for production)
      proofProvider = createHttpClientProofProvider(
        config.proofServerUrl,
        zkConfigProvider
      );
    } else {
      // Use local proof generation (works but slower)
      console.warn('‚ö†Ô∏è  No proof server configured, using local proof generation');
      proofProvider = createHttpClientProofProvider(
        undefined, // No remote server
        zkConfigProvider
      );
    }

    console.log('‚úÖ Midnight providers created successfully');

    return {
      zkConfigProvider,
      publicDataProvider,
      privateStateProvider,
      proofProvider,
      walletProvider: walletApi,
    };
  } catch (error) {
    console.error('‚ùå Failed to create Midnight providers:', error);
    throw error;
  }
}

/**
 * Initialize EdgeChain contract instance
 */
export async function initializeEdgeChainContract(
  providers: any,
  contractAddress: string
): Promise<EdgeChainContract<any>> {
  console.log('üöÄ Initializing EdgeChain contract...');
  console.log(`   Contract address: ${contractAddress}`);

  try {
    // Create contract instance with providers
    // The Contract class is generated by the Compact compiler
    const contract = new EdgeChainContract({});

    // Note: The actual deployment/connection logic depends on Midnight.js SDK
    // This is a simplified version. The real implementation will use:
    // - createContractInstance() or similar from Midnight.js
    // - Wire up providers to contract instance

    console.log('‚úÖ Contract instance created');

    return contract;
  } catch (error) {
    console.error('‚ùå Failed to initialize contract:', error);
    throw error;
  }
}

/**
 * Parse ledger state from contract
 */
export function parseLedgerState(state: any): Ledger {
  return ledger(state);
}

/**
 * Deploy EdgeChain contract (for initial deployment)
 */
export async function deployEdgeChainContract(
  walletApi: DAppConnectorAPI,
  contractBytecode: ArrayBuffer
): Promise<string> {
  console.log('üöÄ Deploying EdgeChain contract...');
  console.log(`   Contract size: ${(contractBytecode.byteLength / 1024).toFixed(2)} KB`);

  try {
    // Enable wallet if not already enabled
    const enabledWallet = await walletApi.enable();
    console.log('‚úÖ Wallet enabled');

    // TODO: Use Midnight.js deployment API when available
    // For now, this is a placeholder
    // Real implementation will be something like:
    // const deployment = await deployContract(enabledWallet, contractBytecode);
    // return deployment.contractAddress;

    throw new Error(
      'Contract deployment requires Midnight.js deployment API. ' +
      'Please use Midnight CLI or devnet deployment tools.'
    );
  } catch (error) {
    console.error('‚ùå Deployment failed:', error);
    throw error;
  }
}

/**
 * Utility: Convert hex string to Uint8Array
 */
export function hexToBytes(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
  }
  return bytes;
}

/**
 * Utility: Convert Uint8Array to hex string
 */
export function bytesToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Utility: Hash model weights (SHA-256)
 */
export async function hashModelWeights(weights: any): Promise<Uint8Array> {
  // Convert weights to JSON string
  const weightsStr = JSON.stringify(weights);

  // Create SHA-256 hash
  const msgUint8 = new TextEncoder().encode(weightsStr);
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);

  return new Uint8Array(hashBuffer);
}
